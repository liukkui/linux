# 网络协议和管理

>网络概念：  
OSI模型：  
网络设备：  
TCP/IP: -TCP&UDP区别 -TCP首部 -TCP的三次握手和四次挥手   
配置网络  
实现网路组  
测试网络  
网络工具  


网际层协议：包括：IP协议、ICMP协议、ARP协议、RARP协议.  
传输层协议：TCP协议、UDP协议.  
应用层协议：FTP、Telnet、SMTP、HTTP、RIP、NFS、DNS等.  

1.网络概念：  
位和字节的区别，1Gbps、100Mbps都是以位为单位的，10M/s是以字节为单位的网络拓扑等  
2.OSI模型：  
七层模型：  
application、persention、session、transport、network、data-link、physical  
7.应用层： 提供各种程序的界面，浏览器，通信软件等   
6.表示层： 数据的表达：ascii,utf-8,加密解密，压缩解压缩等  
5.会话层： 建立、管理主机之间的会话  
4.传输层： 数据报文格式：单位：段segent，建立终端到终端的通信-保证数据可靠性传输-tcp协议等  
3.网络层: 单位：包、报文package,记录逻辑地址：ip，路由、等-支持逻辑寻址、数据传输的路径选择  
2.数据链路层： 单位：帧,将物理层传上来的0,1进行组合并格式化组成 -帧frame-记录目标地址和源地址(物理地址：mac)-检查数据报文的错误等. -链路间的通信   
1.物理层： 单位：比特bit,将各种网络设备进行物理层的确保按规范进行链接保证正常通讯,即只要0和1. -形成比特流


通信过程  
a.发送端进行封装、接收端进行解封装、  
  层层封装：数据+应用层报头+TCP/UDP报头+IP报头+帧头部=物理层的0101  
b.解封装的过程：  
  下层协议为上层协议提供服务：因为上层有各种协议，所以在向上传递时，会有标记来体现出上层协议的类型  
  层层解封装：物理层的0101=数据+应用层报头+TCP/UDP报头+IP报头+帧头部   
   所谓的丢包：是指发生在网络层  
c.数据位bit、数据帧frame、数据包packet、数据段segent、其它层都是message -都统称为PDU-协议数据单元是指对等层次之间传递的数据单位  


三种通讯方式：  

单播：unicast  
    目标发送报文时，目标地址是网络中的一个设备，称为单播  
广播：broadcast  
    目标发送报文时，目标地址是一定范围内网络中的所有设备，称为广播  
组播：multicast  
    目标发送报文时，目标地址是网络中的部分主机设备，称为多播或组播  

局域网：LAN：Local Area Netwoek 本地区域网络 -基础广播机制进行通讯  
广域网：wan：Wdie  Area Netwoek -基于点对点进行通讯  

非屏蔽式双绞线-UTP  

T568B：橙白 橙 绿白 蓝 蓝白 绿白 棕白 棕 -最大程度上抵消彼此的电磁干扰  
      低于100M时，一般用12/36两组 高于100M时，一般同种颜色的绞合在一起-直连线  
T568A  
      单独两台电脑直连时用T568A  
      100M以内时，1 2 TX+接收 3 6 RX+发送 13、26对调既可 一边按T568B做，一边按T568A做叫交叉线  
      新设备自动识别直连线或者交叉线  


单工：单向传输 -百兆以内  
半双工：一个时间只能单向传输  
全双工：可以同时传输和接收 -千兆以上-单模（激光）-多模光纤  


以太网： -工作在数据链路层  
   不仅仅可以把网络连接起来，还规定了数据帧的报文结构  
   有限以太网和无线以太网wifi  

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

数据链路层协议之以太网帧结构  

![以太网帧头部](https://github.com/liukkui/picture/raw/网络相关/以太网帧报文头部.png)

以太网帧结构：固定长度是(8+6+6+2=22)  
   
    Preamble Destination  Source  Type   Data   FCS

    前导信息  目标地址      源地址  type   Data    FCS

字节：  8         6           6      2   46-1500   4

1.前导信息：网卡传输时，标记以太网帧的开始  
2.FCS:校验位，如果数据错误，网卡会把数据直接扔掉  
3.以太网帧的最长长度：72-1526字节  
  除去前导信息和FCS则是用户关心的有效信息：60-1514字节 -即各种抓包软件抓取的有效字节数  

Destination:6个字节，48位，2^48个物理地址（mac）  
Source:6个字节，48位，2^48个物理地址（mac）  
Type：体现上层协议的类型  
Data:包含上层网络层、传输层、应用层的头部信息+data数据信息  

抓包：wireshark，指定要抓的网卡  
tcpdump -i eth0 -nn -X  -指定网卡显示数字二进制信息 捕获到达该网卡的所有数据包  

  
CSMA/CD 冲突检测的载波侦听多路访问  
冲突域：一个主机发送报文，另一主机也发送报文，产生冲突，两个主机在一个冲突域  
广播域：一个主机发送广播，另一主机收到，两个主机在一个广播域  -广播泛洪  
网桥/交换机能隔断冲突域但不能隔断广播域  

网桥/以太网桥的工作原理  
1.具有转发功能，所有不能隔断广播域  
2.交换机有镜像端口  
3.主机都连到交换机的一个端口，有效隔断冲突域   
4.网桥和交换机内部有写在内存中  
    交换机/网桥会读取数据报文中的源地址和目标地址，而交换机有具有学习功能  
    则将数据报文中的源地址mac -内存中记录接口和MAC的对应关系  
  而记录在内存中的是主机的mac地址，而不是广播地址，因为广播地址的mac地址表现为6*8-48个1，不会存在内存表中  
   a. a->b 进行通讯，则内存中会记录macA和B与对应的交换机端口，第二次通讯则不会影响其他主机  
   b. 所以如果A发一个广播，广播的mac地址则不会存在交换机内存中，其他主机都能收到，即广播泛洪  

路由器： -网络层的设备  

vlan：  
trunk协议:  
  多个交换机是通过trunk干线相连，而trunk干线不属于任何vlan，属于公共干线  
  不同vlan的主机如果要通讯，在通过trunk干线的瞬间，修改数据报文结构，在标准的以太网帧内加上一段记录  vlan信息的数据，传给下一个交换机.
  

-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

Internet/网络层协议：  

IP协议，ICMP协议，ARP协议，RARP协议  
 
ICMP协议：ping命令  
   属于网络层的子层，建立在网络层之上  
作用：检查网络是否正常，根据网络状态提示，可以发现网络出现了什么问题  
      type 8表示请求报文，type 0 表示回应报文  
      配置安全策略的时候，可以根据type类型，判断是ping出去的包还是回应包  
      可以配置 cat /proc/sys/net/ipv4/icmp_echo_ignore_all -0不忽略 -1忽略 关闭ping的回应报文  


ARP协议  
  Address Resolution Protocol:地址解析协议  
  基于广播机制  
  将IP地址解析成MAC地址，保存到arp缓存表中  
  作用：通过广播机制，第一次通讯时，将IP发出去，如果该IP存在，则会把MAC地址响应该广播  
        然后在每台主机的arp缓存表中,记录对方的IP和MAC地址，以备下次再通讯    
  arp -n 可以查看ARP缓存表中的信息  

特殊arp:免费arp 每次开机前都会广播查询该IP是否有其他主机正在使用，避免IP冲突  

安全隐患：冒充ARP广播的IP地址，所以一般https加密.  

arping -I eth0  192.168.34.100 可以通过响应的mac地址个数来判断地址是否冲突  

跨路由的ARP实现机制：  
  a.需要配置网关   
  b.不在一个网段时，Arp广播找不到对方地址，则会找该网段的网关MAC，通过网关广播出去，知道找到对方IP  

RARP:反向arp  
  作用：先将IP和MAC地址进行绑定，当主机开机时，会通过广播把自己的MAC地址发送出去，然后获得服务器上已绑定的IP.  


IP协议  

![IP头部](https://github.com/liukkui/picture/raw/网络相关/ip报文头部.png)


版本:占4位,指 IP   

首部长度:占4位,可表示的最大数值是15个单位，一个单位为4字节，因此IP的首部长度的最大值是60字节  

区分服务:占8位,用来获得更好的服务,在旧标准中叫做服务类型,但实际上一直未被使用过.后改名为区分服务.只有在使用区分服务(DiffServ)时,这个字段才起作用.  

总长度:占16位,指首部和数据之和的长度,单位为字节,因此数据报的最大长度为65535字节.总长度必须不超过最大传送单元 MTU
标识:占16位,它是一个计数器,通常，每发送一个报文，该值会加1，也用于数据包分片，在同一个包的若干分片中，该值是相同的 

标志(flag):占3位,目前只有后两位有意义
   DF： Don’t Fragment 中间的一位，只有当 DF=0 时才允许分片
   MF： More Fragment 最后一位，MF=1表示后面还有分片,MF=0 表示最后一个分片
片偏移:占12位,指较长的分组在分片后，该分片在原分组中的相对位置.片偏移以8个字节为偏移单位

生存时间:占8位,记为TTL (Time To Live) 数据报在网络中可通过的路由器数的最大值,TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字
RFC 指定,当前值为 64.发送 ICMP 回显应答时经常把 TTL 设为最大值 255

协议:占8位,指出此数据报携带的数据使用何种协议以便目的主机的IP层将数据，上层协议TCP-6/UDP-17的类型

部分上交给哪个处理过程, 1表示为 ICMP 协议, 2表示为 IGMP 协议, 6表示为
TCP 协议, 17表示为 UDP 协议
首部检验和:占16位,只检验数据报的首部不检验数据部分.这里不采用 CRC 检验
码而采用简单的计算方法
源地址和目的地址:都各占4字节,分别记录源地址和目的地址


-----------------------------------------------------------------------------------
-----------------------------------------------------------------------------------

传输层协议：之TCP协议、UDP协议。

TCP/IP协议栈  
1.传输控制协议 -Transmission Control Protocol/Internet Protocol  

2.tcp/ip模型 对比OSI的七层模型  
  tcp/ip的5层模型  
  5.应用层  
  4.传输层  TCP&UDP协议  
  3.Internet层/网络层   -IP协议  
  2.数据链路层  
  1.物理层  


TCP协议和UDP协议的区别：  

TCP:传输控制协议  UDP:用户数据报协议   
相同：都是传输层协议  
不同：  
  1.Connection Type方式不同：  
    TCP-面向连接：通讯双方在利用某个协议前，要先通过发送报文测试，确认网络是正常连接的.  
    UDP-非面向连接：只负责发送报文，而不确认网络是否连接  
  2.Sequencing:序列化不同  
    TCP：每个数据在用tcp传输的时候，每个是数据报文是有编号的 -数据报文按照编号进行组合可以保证数据的正确性  
    UDP：无次序，根据接收端接收到每个数据报文的时间确定先后顺序 -所以组合起来的数据报文可能是错的  
  3.使用场景不同：  
    TCP:用于文件下载,邮件传输等  
    UDP：视音频等   


TCP特性  

TCP/IP协议工作原理：  
a.发送端进行封装、接收端进行解封装、  
  层层封装：数据+应用层报头+TCP/UDP报头+IP报头+帧头部=物理层的0101  
b.解封装的过程：  
  下层协议为上层协议提供服务：因为上层有各种协议，所以在向上传递时，会有标记来体现出上层协议的类型  
  层层解封装：物理层的0101=帧头部+IP报头+TCP/UDP报头++应用层报头+数据  

TCP包头 -固定长度20字节  

TCP的固定首部包括：  
![tcp头部](https://github.com/liukkui/picture/raw/网络相关/tcp报文头部.png)

1.端口号：下层协议为上层协议提供服务，传输层上层为应用层  
        传输层传给给应用层时，由于应用层协议有多种，所以通过端口号来标识传给哪一种应用层协议，即应用程序的唯一标识  
        端口号有16位，理论上有2^16=65536 0-65535个端口号  

   如： /etc/services 记录系统中服务使用的端口号  
        服务端端口号：  
        0-1023:系统端口号-仅管理员可用  
        http:tcp80  https:tcp443 ssh：tcp22 ftp：21 telnet:23 dhcp:67,68 kerberos:88-加密服务  
        snmp:161    mysql:tcp3306 oracle:1521 sqlserver:1433 SMTP：25 pop:110 imap:143 vnc:5900  
        客户端端口号：随机分配  
        /proc/sys/net/ipv4/ip_local_port_range 可以通过修改配置文件，分配更少或更多的端口号 -如代理服务器

2.序列号seq=Sequence Number(32bit)  
   tcp协议具有序列性：  
   用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记  
   tcp协议会把数据切割成一个个段(segent),接收端根据序列号组合成完整数据 最多2^32段  

3.确认号ack=Acknowledgement Number(32bit)        
   -区别于ACK标志位  
   tcp协议具有序列性和双向性：  
   发送端发过来的包接收端收到后，会回复一个确认号来表示已收到,只有ACK标志位为1时，确认序号字段才有效Ack=Seq+1。    
 注意：发送端和接收端都有各自的序列号和确认号    
       即在三次握手时，会发送各自的sn号和an号，在下面三次握手具体体现  

4.6个标志位: -非1即0  
  重要的标志位：ACK SYN FIN   
  需要注意的是：  
                （A）不要将确认序号Ack与标志位中的ACK搞混了。  
                （B）确认方Ack=发起方Req+1，两端配对。   

  ACK：确认序号有效;  
       表示是否前面确认号字段是否有效。只有当ACK=1时，前面的确认号字段才有效。TCP规定，连接建立后，ACK必须为1,带ACK标志的TCP报文段称为确认报文段  
  
  SYN：发起一个新连接;   
       在建立连接时使用，用来同步序号。当SYN=1，ACK=0时，表示这是一个请求建立连接的报文段；当SYN=1，ACK=1时，表示对方同意建立连接。SYN=1，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为1，带SYN标志的TCP报文段称为同步报文段  
  
  FIN：释放一个连接;  
       表示通知对方本端要关闭连接了，标记数据是否发送完毕。如果FIN=1，即告诉对方：“我的数据已经发送完毕，你可以释放连接了”，带FIN标志的TCP报文段称为结束报文段  
  
  URG：紧急指针（urgent pointer）有效;  
      表示本报文段中发送的数据是否包含紧急数据。后面的紧急指针字段（urgentp ointer）只有当URG=1时才有效  
  
  PSH：接收方应该尽快将这个报文交给应用层;  
       提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。  
       如果为1，则表示对方应当立即把数据提交给上层应用，而不是缓存起来，如果应用程序不将接收到的数据读走，就会一直停留在TCP接收缓冲区中  
  
  RST：重置连接;  
       如果收到一个RST=1的报文，说明与主机的连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。  
       或者说明上次发送给主机的数据有问题，主机拒绝响应，带RST标志的TCP报文段称为复位报文段  
 
 5.TCP的最大报文长度 1500-tcp头部-IP头部=1460  
   最大报文段长度MSS;  
   MTU和MSS的关系： MTU=MSS+IP Header+TCP Header  
   通信双方最终的MSS值=较小MTU-IP Header-TCP Header  


TCP三次握手  

![tcp三次握手](https://github.com/liukkui/picture/raw/网络相关/tcp三次握手.png)

在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接:    
客户端和服务端开始状态：总共5种状态    
客户端：close状态    
服务端：Listen监听状态    

第一次握手：建立连接时,客户端发送SYN包(SYN=1),序列号seq=x 到服务器,客户端close进入SYN_SEND状态,等待服务器确认；   
SYN：同步序列编号(Synchronize Sequence Numbers)   
SYN=1(客户端发起与服务端通信请求),seq=x(客户端发起数据报文的序号)  

第二次握手：服务器收到SYN包,必须确认客户的SYN（ack=x+1）,同时自己也发送一个SYN包（seq=y）,即SYN+ACK包,此时 服务器LISTEN进入SYN_RECV状态；   
    SYN=1(服务器发起与客户端通信请求),ACK=1(确认前面的包收到了);  
    seq=y(服务器发起数据报文的序号),ack=x+1(确认并回复客户端发下一个数据报文)  

第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,客户端和服务器从  SYN_SEND，SYN_RECV状态进入ESTABLISHED状态,完成三次握手.  
    ACK=1(客户端再次确认),seq=x+1(发送第二个包)，ack=y+1(确认收到回复服务端发下一包)  

完成三次握手,客户端与服务器开始数据传输  
 


sync半连接和accept全连接队列  

linux内核中：  
1.客户端向服务端发送通信请求消息后，实际上是先进入到服务端的半连接队列 sync queue,处于等待状态的队列  
  在文件中有数量限制 /proc/sys/net/ipv4/tcp_max_syn_backlog  -建议调整大小为1024以上  

2.客户端向服务端发送同步消息后，通过了tcp的三次握手后，进入传输状态，真正处于会话状态的即全连接队列 accept queue  
  处于会话的请求也有数量限制： /proc/sys/net/core/somaxconn  -建议调整大小为1024以上

安全隐患：  
  所以如果服务端的半连接队列被占满时，第一次握手都不能建立;全连接队列占满时，处于半连接队列的请求也都不能处理

  半连接队列释放空间需要一定的时间，所以一般通过配置防火墙来拒绝这种半连接行为


TCP四次挥手  

  由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，  
收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。  
首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。  
    
  此时服务端和客户端都处于LISTEN状态，5种状态  

  （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
       FIN=1(给服务端发送断开请求);seq=u  
  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。  
       ACK=1(确认收到回复);seq=v;ack=u+1；并发送剩余数据  
  （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。  
       剩余数据传输完毕后，FIN=1(服务端也发起断开请求)；ACK=1；  
       seq=w(和前面的v没关系-因为有传输了剩余数据包)，ack=u+1  
  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。  
       ACK=1(客户端同意请求);seq=u+1;ack=w+1  


备注：  
  （1）三次握手是什么或者流程？四次握手呢？答案前面分析就是。  
  （2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？  
      这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。  
      而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，  
      所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。  


UDP协议功能：  
     工作在传输层  
     提供不可靠的网络访问  
     非面向连接协议  
     有限的错误检查  
     传输性能高  
     无数据恢复特性  



主机间的通信过程  

路由 -> 判断对方主机是否在一个网段 -> ARP -> tcp三次握手 -> Data传输 -> DNS解析 UDP-> HTTP  


----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

IP地址  

作用：标识每个网络设备处于网络位置；即属于哪个网段，不同网段间的设备通信则通过路由来实现
IP地址由两部分组成  
  • 网络 ID：标识网络;每个网段分配一个网络ID  
  • 主机 ID：标识单个主机;由组织分配给各设备
  

32位二进制  
第一种划分方式  
A类: 255.0.0.0， 8  
  0 000 0001 - 0 111 1111   
  127个A类，127用于回环，1-126  
  2^7-1个A类  
  容纳多少个主机：2^24-2  
  主机位全0：网络地址/此网段的网络地址  
  主机位全1：广播地址/此网段的广播 255.255.255.255是全网广播  
B类：255.255.0.0， 16  
  10 00 0000- 10 11 1111  
  128-191  
  129.1.0.0.  
  130.1.0.0  
  64个B类，2^14个B类网  
  容纳多少个主机:2^16-2  
C类：255.255.255.0， 24   
  110 0 0000 - 110 1 1111    
  192-223  
  32个C类, 2^21个C类网  
  容纳多个少个主机：2^8-2  
D类：多播地址   
  1110xxxx.x.y.z  
  224-239.x.y.z  
E类：  
  11110xxx.x.y.z  
  240-254.x.y.z  

私有地址：  
  A类：10.0.0.0/8  
  B类：172.16.0.0/16-172.31.0.0/16  
  C类：192.168.0.0/24-192.168.255.0/24  

第二种划分方式  
   无类域间路由CIDR  
   打乱了A,B,C类的划分方式，网络ID位和主机ID位数量不确定  
   一个网络中主机最大数=2^主机ID位数(32-网络ID位数)-2=2^(32-网络ID位数)-2    
   网络数=2^可变网络ID位  
   CIDR表示法：IP/网络ID位数  
   网络ID值=IP与子网掩码  
   划分子网：一个大网划分成多个小网，网络ID位变多，主机ID位才变少，网络ID向主机ID借位N,分成2^N个小网  
   合并超网：多个小网合并成一个大网，主机ID向网络ID借  
  

netmask子网掩码：32bit二进制 -对应于网络ID位为1主机ID位为0  

特殊地址  
0.0.0.0  
0.0.0.0不是一个真正意义上的IP地址。它表示所有不清楚的主机和目的网络  
255.255.255.255  
限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机  
127.0.0.1～127.255.255.254  
本机回环地址，主要用于测试。在传输介质上永远不应该出现目的地址为“127.0.0.1”的 数据包224.0.0.0到239.255.255.255  

组播地址，224.0.0.1特指所有主机，224.0.0.2特指所有路由器。224.0.0.5指OSPF路由器，地址多用于一些特定的程序以及多媒体程序  
169.254.x.x  
如果Windows主机使用了DHCP自动分配IP地址，而又无法从DHCP服务器获取地址，系统会为主机分配这样地址  


练习：  
1.  
100.123.199.124/20  
  主机数  2^12-2  
  子网掩码 255.255.240.0   
  网络ID:100.123.192.0/20  
  最小和最大IP:100.123.192.1 --- 100.123.207.254  
  100.123.11000111.124  
  255.255.240.0   
  100.123.1100 0000.1    100.123.192.1  
  100.123.1100 1111.254  100.123.207.254  

2.  
10.0.0.0/8 给32省份划分各自子网 2^5=32  
  1.子网子网掩码 255.248.0.0   
  2.最小子网，最大子网的网络ID  
    10.00000  000.0.0  10.0.0.0/13  
    10.11111  000.0.0  10.248.0.0/13  
  3.每个子网主机数？2^19-2  
  4.第20个子网分给河南使用，最小IP10.152.0.1，最大IP范围10.159.255.254  

3. 
河南省10.152.0.0/13 给15个地市，划分各自子网 2^N>=15 N=4  
 1.子网子网掩码  17 255.255.128.0  
 2.最小子网，最大子网的网络ID  
   10.10011  000.0  0000000.0 10.152.0.0/17  
   10.10011  111.1  0000000.0 10.159.128.0/17  
 3.每个子网主机数？ 2^(32-17)-2   
 4.最大子网的最小IP，最大IP范围 10.159.128.1-10.159.255.254  
   10.10011  111.1  0000000.0  
   10.10011  111.1  0000000.1  10.159.128.1  
   10.10011  111.1  1111111.254 10.159.255.254  

4.  
 河南省10.152.0.0/13 给87个区县，划分各自子网  2^7=128  
  1.子网子网掩码  /20 255.255.240.0  
  2.最小子网，最大子网的网络ID  
    10.10011 000.0000|0000.0  10.152.0.0/20  
    10.10011 111.1111|0000.0  10.159.240.0/20  
  3.每个子网主机数？ 2^(32-20)-2  
  4.最大子网的最小IP，最大IP范围   
    10.10011 111.1111|0000.00000001 10.159.240.1/20  
    10.10011 111.1111|1111.11111110 10.159.255.254/20  

合并超网：  
  作用：精简路由器路由表的压力，且便于查询  
  方法：取共同的网络ID位  


合并下面3个网段：  
220.78.168.0  220.78.10101 000.0  
220.78.169.0  220.78.10101 001.0  
220.78.175.0  220.78.10101 111.0    
共同网络ID位 --> 220.78.10101 000.0  
子网        --> 220.78.168.0/21  

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

跨网络通信：路由  
路由分类：  
 主机路由  
 网络路由  
 默认路由  

路由表：  
目标网络ID：目标IP所在网络ID -计算网络ID     
接口：本设备要发送数据包到目标，从哪个接口发送出来，才能到达  
网关：到达目标网络，需要将数据交给下一个路口哪个接口的对应的IP，临近路由接口的IP  

 


动态主机配置协议DHCP  

基于UDP协议  
源MAC是当前主机；目标MAC是广播48个1；12个f  
源ip:0.0.0.0     目标ip：255.255.255.255 即广播  


----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

基本网络配置  
 
一般包括如下内容：  
主机名  
IP/netmask  
路由：默认网关  

主机名：centos6上： 修改：/etc/sysconfig/network/etc/sysconfig/network   
                        /etc/hosts  --不添加不能解析主机名  
       centos7上：修改： /etc/hostname 或者hostnamectl set-hostname centos77.localdomain  
                        /etc/hosts  --不添加也可以自动解析  
同时修改对应的hosts文件：将修改的主机名添加到127.0.0.1的最后，hosts文件提供解析功能，将主机名解析为Ip  
hosts文件     
   /etc/hosts文件也有名字解析功能 -添加hosts文件中加入ip和域名的对应关系  
   hosts文件解析优先级高于DNS  

DNS服务器:主DNS服务器；次DNS服务器；第三DNS服务器；  
   功能：把名字解析成ip地址进行通信  
  
备注：更改优先级的文件 /etcnsswitch.conf  
               #hosts:     db files nisplus nis dns  
               hosts:      files dns myhostname  
   file代表hosts,dns=DNS,调换位置可以修改优先级关系  
   但是由于hosts本地文件，更加方便可靠，一般不会修改优先级；而且在搭建集群时，修改hosts文件  

1.直连网络的路由主机自动生成 route -n  
```bash
  [root@centos7 ~]#route -n  
  Kernel IP routing table
  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
  0.0.0.0         172.18.0.1      0.0.0.0         UG    101    0        0 ens37
  172.18.0.0      0.0.0.0         255.255.0.0     U     101    0        0 ens37
  192.168.34.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33
  192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
```
CentOS 6网卡名称  
接口命名方式：CentOS 6  
  以太网：eth[0,1,2,...]  
  ppp：ppp[0,1,2,...]  
网络接口识别并命名相关的udev配置文件：  
/etc/udev/rules.d/70-persistent-net.rules  
查看网卡：  
dmesg |grep –i eth  
ethtool -i eth0  
卸载网卡驱动：  
modprobe -r e1000  
rmmod e1000  
装载网卡驱动：  
modprobe e1000

实例：更改centos6上的网卡驱动名  
```bash
[root@centos6 ~]#cat /etc/udev/rules.d/70-persistent-net.rules
# PCI device 0x8086:0x100f (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:e1:03:f5", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"
# PCI device 0x8086:0x100f (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:e1:03:ff", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"
```
卸载网卡驱动，重新加载或者卡机重启生效  
 ethtool -i eth1 查看网卡驱动模块名称  
 lsmod 查看内存中加载进去的所有相关模块 & dmesg -系统启动加载的模块  
 lsmod | grep "e1000"  或者dmesg | grep "eth1"  
 modprobe -r e1000 或者 rmmove e1000 -从内存中卸载网卡驱动模块,硬盘上还存在,只是不生效了  
 modprobe e1000 -重新加载生效  

----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------

网络配置相关新旧命令解析：  

网络配置命令： -新旧命令解析  
静态指定:  
前两个可以生效，但重启失效；后面两个可以存到配置文件，但不能立即生效  
旧的网络配置工具：ifconfig, route, netstat   --来自于net-tools包  
新的网络配置工具：ip: object {link, addr, route}, ss, tc --来自iproute包  
system-config-network-tui，setup  
配置文件  
动态分配：  
DHCP: Dynamic Host Configuration Protocol  

----------------------------------------------------------------------------------------------

旧命令：route;netstat;ifconfig  

路由器配置之-route命令  
route命令  
路由管理命令  
查看：route -n  数字化显示，默认路由default=0.0.0.0  
添加：route add
route add [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]
目标：192.168.1.3 网关：172.16.0.1
route add -host 192.168.1.3 gw 172.16.0.1 dev eth0
目标：192.168.0.0 网关：172.16.0.1
route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0
route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0
所做出的改动重启网络服务或主机后失效.

配置的IP是存在内核的，路由表决定数据报文是否能出去;

默认路由，网关：172.16.0.1
route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1
route add default gw 172.16.0.1
删除：route del
route del [-net|-host] target [gw Gw] [netmask Nm] [[dev] If]
目标：192.168.1.3 网关：172.16.0.1
route del -host 192.168.1.3
目标：192.168.0.0 网关：172.16.0.1
route del -net 192.168.0.0 netmask 255.255.255.0


动态路由：
通过守护进程获取动态路由
• 安装quagga包
• 支持多种路由协议：RIP、OSPF和BGP
• 命令vtysh配置


实验：
环境：当前主机A的网络：192.168.34.101/24 主机B：192.168.34.103/24,彼此能够正常通讯

1.主机A配置到达网络中一个主机2.2.2.2的主机路由 -gw至少是主机A网段中的一个地址
   route add -host 2.2.2.2 gw 192.168.34.100 dev eth0 
   gw:必须和当前主机是一个网段
  删除：route del -host 2.2.2.2 gw 192.168.34.100
2.主机A配置到达主机B的主机路由 -原本正常通讯则会不通
  route add -host 192.168.34.103 gw 192.168.30.200 dev eth0(不存在的网关地址)
  如果新加的主机路由网关不存在，即使是在一个网段，由于主机路由的优先级高，网络也会不通

3.新增到达192.168.30.0/24网段的路由
    route add -net 192.168.30.0/24 gw 192.168.34.200 dev eth0
  删除：route del -net 192.168.30.0/24 gw 192.168.34.200 dev eth0

4.删除主机A上默认生成到达自己网段的192.168.34.0/24的网络路由
  测试 主机B ping 主机A没有响应，原因？
  
  原理：先ARP广播-再通过路由回应
  a.主机B ping A时，实际上主机B有到达192.168.34.0/24网段的路由，可以发出去
  b.在主机A上抓包时,可以看到ARP广播，由于删除了主机A到达192.168.34.0/24的路由，所以主机A无法回应
    [root@centos7 data]#tcpdump -i ens33 -nn
    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
    listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes
    14:20:54.016056 ARP, Request who-has 192.168.34.103 tell 192.168.34.101, length 46
    14:20:55.016029 ARP, Request who-has 192.168.34.103 tell 192.168.34.101, length 46
  而且通过wireshark抓包时可以看出ARP发出的广播，没有回应信息

  4-1：如果再删除主机B上到达192.168.34.0/24的路由
       则会通过默认路由去找主机A
       wireshark抓包时则会看不到ARP广播
  4-2：如果把主机B上的默认路由也删除，则直接提示：网路不可到达

5.主机A配置两个默认路由时，metric的值越小，优先级越高 
  route add default gw 192.168.0.100 metric 200 -添加默认路由时指定优先级


实验1：
关闭防火墙；SELinux 关闭
主机模拟路由器需要关闭： cat /proc/sys/net/ipv4/ip_forward=1
   当数据报文拆分到IP头部时，看到目标地址不是自己时，会抛弃报文，达不到转发路由器的转发功能
   0 -代表不忽略不能转发  1 -忽略从而启动转发功能
当然了，真正的路由器带有转发功能

环境：仅主机模式下添加VMware10,VMware11，VMware12三个网段
主机A：仅主机模式下的VMware10网络，修改主机名为A 192.168.34.100/24
R1:仅主机模式-eth0-VMware10网络，桥接网卡-eth1-VMware11网络，修改主机名为R1
    - 192.168.34.200/24             10.0.0.1/8
R2：仅主机模式-eth0-VMware12网络，桥接网卡-eth1-VMware11网络，修改主机名为R2
    - 172.18.0.200/16                10.0.0.2/8              
主机B：仅主机模式下的VMware12网络，修改主机名为B  172.18.0.100/16

路由表配置：
主机A：在ifcfg-eth0文件，配置gateway=192.168.34.200
      或者指定：route add default gw 192.168.34.200
R1: route add -net 172.18.0.0/16 gw 10.0.0.2 -配置R1到达主机B的路由表

R2:route add -net 192.168.34.0/24 gw 10.0.0.1 -配置R2到达主机A的路由表

主机B：在ifcfg-eth0文件，配置gateway=172.18.0.200
      或者指定：route add default gw 192.18.0.200


实验2：在上面R1，R2之间再加一个路由R3

环境：仅主机模式下添加VMware10,VMware11，VMware12三个网段
主机A：仅主机模式下的VMware10网络，修改主机名为A 192.168.34.100/24
R1:仅主机模式-eth0-VMware10网络，桥接网卡-eth1-VMware11网络，修改主机名为R1
    - 192.168.34.200/24             10.0.0.1/8
R3：仅主机模式-eth0-VMware11网络，桥接网卡-eth1-VMware13网络，修改主机名为R2
    - 10.0.0.2/8                    172.16.0.1/16         
R2：仅主机模式-eth0-VMware12网络，桥接网卡-eth1-VMware13网络，修改主机名为R2
    - 192.18.0.200/16                 172.16.0.2/16           
主机B：仅主机模式下的VMware12网络，修改主机名为B  172.18.0.100/16

路由表配置： -网络ID：接口：网关
主机A：在ifcfg-eth0文件，配置gateway=192.168.34.200
      或者指定：route add default gw 192.168.34.200
R1: route add -net 172.16.0.0/16 gw 10.0.0.2 -配置R1到达R2的路由表
    route add -net 172.18.0.0/16 gw 10.0.0.2 -配置R1到达主机B的路由表
  或者合并：route add default gw 10.0.0.2   --网关是同一个可以设置默认路由

R3:route add -net 192.168.34.0/24 gw 10.0.0.1 -配置R3到主机A的路由表
   route add -net 172.18.0.0/16 gw 172.16.0.1 -配置R3到达主机B的路由表

R2:route add -net 10.0.0.0/8 gw 172.16.0.1 -配置R2到R1的路由表
   route add -net 192.168.34.0/24 gw 172.16.0.1 -配置R2到达主机A的路由表
  或者合并：route add default gw 172.16.0.1 --网关是同一个可以设置默认路由

主机B：在ifcfg-eth0文件，配置gateway=172.18.0.200
      或者指定：route add default gw 192.18.0.200

在主机A上：traceroute/mtr 192.18.0.100 
          可以看到经过的路由个数,丢包数以及下一跳路由的地址 


在主机B上抓以太网帧的信息： tcpdump -i eth0 -e -nn s0,
可以看到下面信息
源MAC    目标MAC   源IP   目标IP是？ 
R2-eth0  MacB      IPa     IPB

总结：A -> B;数据包在处理时的通信过程：

A：当主机收到数据报文之后的处理原理：即整个网路的通信原理解析：
   解封装过程：
   当主机收到数据报文 ---> 主机网卡收到数据报文 ---> 传到物理层 ---> 数据链路层 --拆分以太网帧报文头部查看目标MAC/判断是否为自己的MAC;是则收不是则抛弃
   --->删除以太网帧报文头部传到网络层 ---> 查看IP报文头部-判断目标IP/是否为自己；是则收不是则抛弃 --->传给传输层-TCP三次握手建立安全连接 
   --->传输数据 ---> 断开连接

B: A-ping-B的过程解析：
   A先进行封装：
   1.A先判断B的网络是不是在自己的路由表可到达的路径 -因为配置了默认路由，可以到达，可以发出数据报文
   2.由于不在一个网络，则抓取目标B的网关IP地址 ---> A通过自己的网关R1-eth0，ARP广播找到B网关R2-eth0的MAC地址 -->找到后传给R1-eth0
   然后A发出去的数据报文中带有的 源MAC=R1-eth0;目标MAC=R2-eth0;源IP=IPA;目标IP=IPB

   所以数据报文经过R1时，解封装过程中-在数据链路层拆分以太网帧的目标MAC是R1,即路由R1自己 --> 传给网络层拆分IP头部信息-看到目标IP=IPB，不是自己则抛弃，
     就不能达到路由器的功能，所以要开启转发功能，即将数据报文往下传给传给R2 -->
   R2接收到数据报文之后，在数据链路层拆分以太网帧的目标是R2,即路由R2自己 -->传到网络层拆分IP头部，目标IP=IPB,则转发到目标IPB.


配置网络接口
ifconfig命令
ifconfig [interface]
ifconfig -a
ifconfig IFACE [up|down]
ifconfig interface [aftype] options | address ...
ifconfig IFACE IP/netmask [up]
ifconfig IFACE IP netmask NETMASK
注意：立即生效,重启网络或主机都会失效
启用混杂模式：[-]promisc

旧命令netstat命令 -查看网络连接状态
-t|tcp: tcp协议相关
-u|udp: udp协议相关
-w|raw: raw socket相关
-l|LISTEN: 处于监听状态
-a|all: 所有状态
-n|number: 以数字显示IP和端口
-e|extend：扩展格式
-p|program: 显示相关进程及PID
常用组合：
-tan, -uan, -tnl, -unl
显示路由表：
netstat {--route|-r} [--numeric|-n]
-r: 显示内核路由表
-n: 数字格式
显示接口统计数据：
netstat {--interfaces|-I|-i} [iface] [--all|-a] [--extend|-e] [--program|-p]
[--numeric|-n]
netstat -i
netstat –I=IFACE  -netstat -I=eth0 
ifconfig -s eth0

实例：统计出现的状态有多少种：
     netstat -ntua |sed -nr '/^tcp/s@.* ([^ ]+) ?@\1@p'|sort|uniq -c
     ss -nta|sed -nr '1!p'|sed -r 's@([^ ]+).* @\1@'|sort|uniq -c


网络配置新命令
ip命令  
配置Linux网络属性：ip命令
ip [ OPTIONS ] OBJECT { COMMAND | help }
OBJECT := { link | addr | route }
ip l/link + options -显示数据链路层的信息
      add
      delete -ip delete eth1 
      set    -ip link set eth0 down/up -开启/禁用数据链路层网卡信息   
   a/addr + options -显示网路层信息
      add  -为网卡添加多个地址 ip addr add 172.16.100.100/16 dev eth0 label eth0:0
      change
      del  -删除网卡地址       ip addr del 172.16.100.100/16 dev eth0 label eth0:0
      flush -清空网卡上添加的所有地址 ip addr flush dev eth0 label eth0:0
   route + options + 网卡名
      add  ip route add 192.168.0.0/24 via 172.16.0.1
           ip route add default via GW dev IFACE -添加网关
      del -删除某个路由信息
      flush -清空路由表
      list


ss命令 =netstat  -显示很快，性能高
格式：ss [OPTION]... [FILTER]
netstat通过遍历proc来获取socket信息，ss使用netlink与内核tcp_diag模块通信获取
socket信息。
选项：
-t: tcp协议相关
-u: udp协议相关  -ss -u -a 显示所有的UDP Socekt
-w: 裸套接字相关
-s： 套接字相关  -ss -s 列出当前socket详细信息
-x： unix sock相关
-l: listen状态的连接   -ss -l 显示本地打开的所有端口
-a: 所有
-n: 数字格式
-p: 相关的程序及PID  -ss -pl 显示每个进程具体打开的socket
-e: 扩展的信息
-m： 内存用量
-o： 计时器信息
   ss -o state established '( dport = :ssh or sport = :ssh )' 显示所有已建立的ssh连接
   ss -o state established '( dport = :http or sport = :http )' 显示所有已建立的HTTP连接

FILTER : [ state TCP-STATE ] [ EXPRESSION ]
 
TCP的常见状态：
tcp finite state machine:
LISTEN: 监听
ESTABLISHED：已建立的连接
FIN_WAIT_1
FIN_WAIT_2
SYN_SENT
SYN_RECV
CLOSED
 EXPRESSION:
dport =
sport =
示例：’( dport = :ssh or sport = :ssh )’
常用组合：
-tan, -tanl, -tanlp, -uan


网络配置文件：
/etc/sysconfig/network

网络接口配置文件：
/etc/sysconfig/network-scripts/ifcfg-INTERFACE_NAME
DEVICE=: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; 
BOOTPROTO={static|none|dhcp|bootp}: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；
IPADDR=: IP地址
NETMASK=：子网掩码
GATEWAY=：设定默认网关；
ONBOOT=：开机时是否自动激活此网络接口；
HWADDR=： 硬件地址，要与硬件中的地址保持一致；可省；
USERCTL={yes|no}: 是否允许普通用户控制此接口；
PEERDNS={yes|no}: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；
不会立即生效，但重启网络服务或主机都会生效；


网络接口配置-bonding

Bonding
将多块网卡绑定同一IP地址对外提供服务，可以实现高可用或者负载均衡。直接给
两块网卡设置同一IP地址是不可以的。通过bonding，虚拟一块网卡对外提供连接，
物理网卡的被修改为相同的MAC地址

工作模式
Mode 0 (balance-rr)
轮转（Round-robin）策略：从头到尾顺序的在每一个slave
接口上面发送数据包。本模式提供负载均衡和容错的能力
Mode 1 (active-backup)
活动-备份（主备）策略：只有一个slave被激活，当且仅当活动的slave接口失
败时才会激活其他slave.为了避免交换机发生混乱此时绑定的MAC地址只有一
个外部端口上可见
Mode 3 (broadcast)
广播策略：在所有的slave接口上传送所有的报文,提供容错能力
active-backup、balance-tlb 和 balance-alb 模式不需要交换机的任何特
殊配置。其他绑定模式需要配置交换机以便整合链接。如：Cisco 交换机需
要在模式 0、2 和 3 中使用 EtherChannel，但在模式4中需要 LACP和
EtherChannel

配置
创建bonding设备的配置文件
/etc/sysconfig/network-scripts/ifcfg-bond0
DEVICE=bond0
BOOTPROTO=none
BONDING_OPTS= “miimon=100 mode=0”
/etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
USERCTL=no
查看bond0状态：/proc/net/bonding/bond0



测试网络工具
 在命令行下测试网络的连通性
显示主机名
hostname
测试网络连通性
ping
显示正确的路由表
ip route
 跟踪路由
traceroute=tracepath=mtr + ip
mtr
确定名称服务器使用
nslookup
host
dig


网络客户端工具
ftp，lftp：子命令：get、mget、ls、help
lftp [-p port] [-u user[,password]] SERVER
lftpget URL
wget [option]... [URL]...
-q 静默模式
-c 断点续传
-P /path 保存在指定目录
-O filename 保存为指定文件名，filename 为 – 时，发送至标准输出
--limit-rate= 指定传输速率，单位K，M等
links URL
--dump
--source 

