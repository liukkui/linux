# 加密和安全 
包括实验：创建私有CA服务器和证书申请

	内容：
		安全机制
		对称和非对称加密 -理解原理
		散列算法 -单向哈希算法
		gpg 	-gpg方式实现对称和非对称加密
		PKI和CA -创建CA和申请证书
		openssl -对称非对称的加密
		证书管理 -证书的查看和吊销

互联网上很多采用类似(对称+非对称+hash)算法组合来实现安全且高效的加密与解密。

## 对称加密算法
	对称加密：加密和解密使用同一个密钥
	DES：Data Encryption Standard，56bits，7个字节秘钥
	3DES：更强的加密方式，即加密3次
	AES：Advanced (128, 192, 256bits)，目前正在使用的，更安全的加密标准，有三种加密
	Blowfish，Twofish
	IDEA，RC6，CAST5
	特性：
	1、加密、解密使用同一个密钥，效率高
	2、将原始数据分割成固定大小的块，逐个进行加密
	缺陷：
	1、密钥过多
	2、密钥分发
	3、数据来源无法确认

概念：未加密的数据叫明文；加密过的数据叫密文
对称加密算法逻辑：
算法：公开
秘钥：不公开
date明文--加密key1--data’密文--解密key2--data明文
如果key1==key2是相等的，同一秘钥，则成为对称加密算法

## 非对称加密算法 -重点内容
	公钥加密：密钥是成对出现
	公钥：公开给所有人；public key
	私钥：自己留存，必须保证其私密性；secret key
	特点：用公钥加密数据，只能使用与之配对的私钥解密；反之亦然
	功能：
	数字签名：主要在于让接收方确认发送方身份
	对称密钥交换：发送方用对方的公钥加密一个对称密钥后发送给对方
	数据加密：适合加密较小数据
	缺点：密钥长，加密解密效率低下
	算法：
	RSA（加密，数字签名）
	DSA（数字签名）
	ELGama
	基于一对公钥/密钥对
	• 用密钥对中的一个加密，另一个解密
## 非对称加密算法原理
	生成公钥/密钥对：P和S
	公开公钥P，保密密钥S
	公钥：*.pub public
	私钥：*.key secret
	eg:
	centos7上 /etc/ssh放着ssh的秘钥 
	特性：
	公钥和私钥是不同长度的字符串
	每个主机上都有自己的私钥和公钥
	用公钥无法推出私钥，私钥可以推出公钥
	某个用户的公钥进行加密只能用自己的私钥进行解密

示例：
1.Bob发送数据给Alice
Bob:public-key=Pb,secret-key=Sb,Pa
Alice:Pa,Sa key(Sa)

第一种加密方式：bob通过alice公钥加密数据发送给alice
实现数据的传输加密功能
Bob --data-Pa加密-data'-Sa解密-data--->Alice


2.数字签名：私钥加密方式
alice如何确认数据是来自Bob？通过bob的私钥数据加密加上alice的，从而alice一定能确认数据报文来自己bob
数据来源的确认功能
Bob --data-Sb加密-data'-Pb解密-data--->Alice  这种用私钥加密方式又称为数字签名
互联网上很多采用这个方式，但是解密效率偏低
 
3.非对称加密
Bob给Alice发送数据报文，如何确保数据不被截获，且Alice可以确认一定是Bob发送的？
应该怎么加密？
Pa[Sb(data)] -数据加密方式
Alice解密：Sa{Pa[Sb(data)]}=Sb(data)  -先确保数据不被截获
Alice再解密：Pb[Sb(data)]=data  -用Bob公钥解密，确认数据报文一定来自Bob
缺点：理论上可以，但是效率偏低，下面会优化加密方式


## 单向散列=单向哈希算法
	将任意数据缩小成固定大小的“指纹”
	• 任意长度输入 -和不同的加密算法有关
	• 固定长度输出
	• 若修改数据，指纹也会改变（“不会产生冲突”）
	• 无法从指纹中重新生成数据（“单向”） ---只能单向,只能加密不能解密
	功能：数据完整性
	常见算法
	md5:128bits(32位16进制数)、sha1:160bits(40位)、sha224、sha256、sha384、sha512
		linux中，用户账号加密采用的是sha512算法
	特点：
		不论数据大小，只要采用相同的加密算法生成的二进制位数都是一样
		hash(data)=digest摘要，又称为指纹
		数据不同，加密算法得出的值(摘要)绝对不同
		得到摘要是不可逆推出原来数据的，所以叫单向哈希算法
	有势：
		1.利用哈希算法能实现只要给出摘要信息，就可以比较出两次给的数据是否为一样的
	常用工具
	• md5sum | sha1sum [ --check ] file
	• openssl、gpg
	• rpm -V
示例：
1.
测试下载的centos镜像是否具有完整性，是否是被修改过
因为：红帽官网下载光盘超过4个小时，地址会发生变化，所以一般从其他地方下载，再通过哈希算法尽心比较

阿里云上centos7的sha1sum生成的摘要，与系统中的光盘进行比较：
3a7cb1f2041fee7c3c99c2afc7f1bf60ac671c73  CentOS-7-x86_64-DVD-1804.iso
[root@centos7 ~]#sha1sum /dev/sr0 
3a7cb1f2041fee7c3c99c2afc7f1bf60ac671c73  /dev/sr0
可以看出数据是完整的

2.批量检查文件的完整性 参照详细命令 md5sum --help
[root@centos7 ~]#md5sum f1 f2 f5 > md5.log
[root@centos7 ~]#md5sum -c md5.log 
f1: OK
f2: OK
f5: OK

3.非对称+hash实现加密：
Bob给Alice发送数据报文，如何确保数据不被截获，且Alice可以确认一定是Bob发送的？
优化加密方式：提高解密效率
Pa{data+Sb{hash(data)}}
效率分许：数据的hash值进行加密，因为hash值很小，用非对称加密，解密比较快
Alice解密：Sa{Pa{data+Sb{hash(data)}}}=data+Sb{hash(data)}
解密先确保数据不被截获
Alice再解密：Pb{Sb{hash(data)}}= hash(data)  得到摘要
然后得到的摘要hash(data)==?data的hash值，如果是则确认数据报文一定来自Bob
缺点：还是采用了最外层的一次非对称秘钥加密，解密时效率还是低，但是还可以进行优化

4.对称+非对称+hash 
再次优化的加密算法
对称key{data+Sb{hash(data)}+Pa{前面的key整体,非对称加密}即对公钥进行加密
解密过程 ：
Alice:Sa{Pa{key}}=Pa{前面的key整体,非对称加密}
key{对称key{data+Sb{hash(data)}}=data+Sb{hash(data)
再重复3算法，去对比数据即，达到安全并高效的目的
在这个算法中，非对称加密的低效率被hash算法和对称算法规避了，提高了整体的算法效率和安全


## gpg命令

## 使用用gpg实现对称加密
	gpg -c file 设置加密 
	手动输入对称秘钥，加密后查看为乱码，加密后生成同名.gpg,file.gpg加密文件
	gpg -d file.gpg  解密，只能查看文件内容
	在另一台主机上解密file
	gpg -o file -d file.gpg 生成新的文件
	- o file 必须写在-d file前面
	备注：对称加密是对文件进行加密
## 使用用gpg实现非对称加密
	备注：生产环境不会直接使用非对称秘钥直接进行加密，此处只列出两主机间hostA&hostB上实现非对称加密的步骤

	在hostA,hostB各自的主机上生成，公钥、私钥
	gpg --list-keys 查看主机上是否有公钥私钥对
	gpg  --gen-key 生成公钥私钥对 
		生成秘钥默认算法：RSA，可选DSA，指定秘钥位数，钥匙有效期，标识钥匙是哪个用户的
		而且，系统会强制为生成的私钥加一个对称秘钥口令
	将hostA公钥导出：
	gpg -a --export -o test.pubkey
	将hostA公钥导入到hostB中
	gpg --import test.pubkey  
	导入后/root/.gnupg/pubring.gpgw文件大小会变大
	在hostB上，对某个文件进行加密
	gpg -e -r test file -->file.gpg,然后传输到hostA上
	在hostA上：
	gpg -o -d file.gpg 可以解密

	删除公钥和私钥
	当前主机上删除其他主机公钥
	gpg --delete-keys test
	当前主机上删除公钥、私钥，需要先删除私钥
	gpg --delete-secret-keys test1
	gpg --delete-keys test

## CA和证书
上述传输公钥，可能会被中间人攻击，替换原有公钥，会造成数据不安全，如arp攻击等技术
所以生产环境中要保证公钥和私钥的安全性，就需要CA和证书
PKI: Public Key Infrastructure
签证机构：CA（Certificate Authority）
注册机构：RA
证书吊销列表：CRL
证书存取库：
X.509：定义了证书的结构以及认证协议标准

下文中具体事例来实现自建CA证书和颁发证书

## SSL安全协议

	SSL/TLS：目前主流使用的是TLS 1.2版本
	称为安全套接层，TLS协议栈,TL协议属于应用层
	功能：机密性，认证，完整性，重放保护
	两阶段协议，分为握手阶段和应用阶段
	握手阶段(协商阶段):客户端和服务器端认证对方身份（依赖于PKI体系，利用数字
		证书进行身份认证），并协商通信中使用的安全参数、密码套件以及主密钥。后续通信使
		用的所有密钥都是通过MasterSecret生成。
	应用阶段:在握手阶段完成后进入，在应用阶段通信双方使用握手阶段协商好的密钥进行安全通		信
![TLS协议栈]()

	TLS协议位于应用层和传输层之间，应用层数据通过加密后,再传到传输层TCP/UDP进行传输

	socket：IP地址+端口号，定位网络中的唯一应用程序
	作用：通过IP地址定位主机，通过端口号定位主机上的应用程序

	Handshake协议：包括协商安全参数和密码套件、服务器身份认证（客户端身 
					份认证可选）、密钥交换
	ChangeCipherSpec协议：一条消息表明握手协议已经完成
	Alert协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，
				fatal类型错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，
				只是会给出错误警告
	Record协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等


	应用层的很多协议都支持SSL协议，HTTP协议是最广泛的的，组合成为:https
	http+tls=https；ftp+tls=ftps
	HTTPS 协议：就是“HTTP 协议”和“SSL/TLS 协议”的组合。HTTP over
	SSL”或“HTTP over TLS”，对http协议的文本数据进行加密处理后，成为二
	进制形式传输

## HTTPS工作原理 -重点内容
HTTP+TLS=HTTPS
HTTPS结构和工作过程，涉及证书、公钥、私钥
![https工作原理]()


 
## OpenSSL
	实现了ssl协议，
	通过ssl将http这些协议进行封装，解决了传统协议不加密的问题，实现了数据安全

	三个组件：
		openssl: 多用途的命令行工具，包openssl
		libcrypto: 加密算法库，包openssl-libs
		libssl：加密模块应用库，实现了ssl及tls，包nss

#### openssl命令

介绍一个编码机制：base64
	由a-z,A-Z,0-9,/,+ 64个字符组成，当然base64只是一个存储方式，本身不带加密
	将数字&字母的ascii转换成二进制，通过6位一组，生成对应的base64编码的组合
	为什么是6位一组？
	因为10进制的63，转换成二进制，最大程度是6位的1，即111111,所以6位一组
	当切分的不是6的整数倍时，不够的用等号=代替
	[root@centos6 data]#echo -n abc | base64
	YWJj
	[root@centos6 data]#echo -n ab | base64
	YWI=

	实现对称，非对称的加密，以及证书管理
	对称加密：
		工具：openssl enc, gpg
		算法：3des, aes, blowfish, twofish
	enc命令：
		帮助：man enc
		加密：
			openssl enc -e -des3 -a -salt -in testfile
			-out testfile.cipher
		解密：
			openssl enc -d -des3 -a -salt –in testfile.cipher
			-out testfile

	单向加密：
		工具：md5sum, sha1sum, sha224sum,sha256sum，openssl dgst
		dgst命令：
			帮助：man dgst
			openssl dgst -md5 [-hex默认] /PATH/SOMEFILE
			openssl dgst -md5 testfile
			md5sum /PATH/TO/SOMEFILE
		MAC: Message Authentication Code，单向加密的一种延伸应用，用于实现
		网络通信中保证所传输数据的完整性机制
			CBC-MAC
			HMAC：使用md5或sha1算法

	生成随机数：
		帮助：man sslrand
		openssl rand -base64|-hex NUM
		NUM: 表示字节数；-hex时，每个字符为十六进制，相当于4位二进制，出
		现的字符数为NUM*2
 这里生成随机口令密码的方式：
 #6代表字节数6*8=48(二进制)/(base64)6位=8字节密码
 [root@centos6 data]#openssl rand -base64 6 
 dOCmvkJa
 cat /dev/urandom | head -c 500|tr -dc '0-9a-zA-Z'|head -c 8
 cat /dev/random | head -c 500|tr -dc '0-9a-zA-Z'|head -c 8

### openssl命令生成私钥&提取公钥
 
	生成密钥对儿：man genrsa
	生成私钥
		openssl genrsa -out /PATH/TO/PRIVATEKEY.FILE NUM_BITS
		(umask 077; openssl genrsa –out test.key )
		(umask 077; openssl genrsa –out test1.key –des 2048) 
		–des/des3 2048为生成的私钥进行对称加密
		因为私钥需要安全性，为了安全，临时指定umask值，所以生成的私钥权限为600
		openssl rsa -in test.key –out test2.key 将加密key解密
	还有一种生成私钥的方式：
		cd /etc/pki/tls/certs
		make /data/ssl /test3.key
		实际上是调用Makefile文件，可参考下面的生成CA证书等实验

	从私钥中提取出公钥
		openssl rsa -in test3.key –pubout –out test3.key.pub
		openssl rsa –in test.key –pubout –out test.key.pub

	随机数生成器：伪随机数字
		键盘和鼠标，块设备中断
		/dev/random：仅从熵池返回随机数；随机数用尽，阻塞
		/dev/urandom：从熵池返回随机数；随机数用尽，会利用软件生成伪随机
		数,非阻



## 重点内容之-用Openssl如何实现(CA)证书的过程 
实验过程：
搭建私有CA？
用户如何取申请证书？
私有CA如何给用户颁发证书？

模拟环境：
centos7当CA服务器
centos6向centos7申请证书：申请的证书要标识出网站的名称，颁发的证书是用于哪个域名的

1.创建私有CA过程

	创建私有CA：
	参考openssl的配置文件：/etc/pki/tls/openssl.cnf文件来创建CA
	三种策略：匹配、支持和可选
	匹配指要求申请填写的信息跟CA设置信息必须一致，支持指必须填写这项申
	请信息，可选指可有可无
	

### 参照/etc/pki/tls/openssl.cnf中重要选项

#### 文件/目录代表的意思

	[ ca ]
	default_ca      = CA_default            # The default ca section  默认CA
	####################################################################
	[ CA_default ] 默认CA包含的信息

	dir             = /etc/pki/CA           # Where everything is kept  
					CA的公共目录
	certs           = $dir/certs            # Where the issued certs are kept 
					被发布的证书&旧的证书存放目录
	crl_dir         = $dir/crl              # Where the issued crl are kept
					被吊销的证书存放目录
	database        = $dir/index.txt        # database index file.
					存放颁发证书的数据库文件.默认不存在需要手动先创建
	#unique_subject = no                    # Set to 'no' to allow creation of
	                                        # several ctificates with same subject.
	new_certs_dir   = $dir/newcerts         # default place for new certs.
					新颁发的证书存放目录
	certificate     = $dir/cacert.pem       # The CA certificate
					自签名证书，局域网内的根CA自证证书
	serial          = $dir/serial           # The current serial number
	下一个证书颁发的编号 16进制数,默认不存在，手动创建，并且指定第一个证书的开始编号
	crlnumber       = $dir/crlnumber        # the current crl number
					下一个吊销证书的编号
	                                        # must be commented out to leave a 
	crl             = $dir/crl.pem          # The current CRL

	private_key     = $dir/private/cakey.pem# The private key
					CA的私钥文件，必须叫cakey.pem
	RANDFILE        = $dir/private/.rand    # private random number file

	x509_extensions = usr_cert              # The extentions to add to the cert

	default_days    = 365                   # how long to certify for
					默认ca有效期
	default_crl_days= 30                    # how long before next CRL
				定义多少天公布新的吊销证书名单
	default_md      = sha256                # use SHA-256 by default
				默认加密算法
	preserve        = no                    # keep passed DN ordering
serial为16进制数00开始
## 创建CA和申请证书必填项

	policy          = policy_match
	# For the CA policy
	[ policy_match ]
	countryName             = match   		三项match是必须一样的
	stateOrProvinceName     = match
	organizationName        = match  		组织必填项，即用户向哪个组织申请证书
	organizationalUnitName  = optional  	optional 不关心是否一样
	commonName              = supplied		supplied是必须提供的，即网站域名
	emailAddress            = optional	

## 创建私有CA和客户端申请证书步骤：
	前提：CA服务器(centos7)要在/etc/pki/CA/目录下
	创建必须要用的文件：index.txt和serial,不创建则报错

	1.先创建自签名证书，必须先生成私钥
		( umask 066;openssl genrsa -out private/cakey.pem 2048)
	2.根据私钥生成自签名证书
	openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650
		-new: 生成新证书签署请求
		-x509: 专用于CA生成自签证书
		-key: 生成请求时用到的私钥文件
		-days n：证书的有效期限
		-out /PATH/TO/SOMECERTFILE: 证书的保存路径

	ountry Name (2 letter code) [XX]:CN    必填项
	State or Province Name (full name) []:beijing 必填项
	Locality Name (eg, city) [Default City]:beijing
	Organization Name (eg, company) [Default Company Ltd]:redhat.com 必填项
	Organizational Unit Name (eg, section) []:devops
	Common Name (eg, your name or your server's hostname) []:ca.redhat.com
	
	在客户端(centos6)上(/data/目录下)操作步骤：
	如果要搭建https或者ftps时需要证书时，如何向CA申请证书？
	1.生成私钥(私钥名为为哪个服务申请的)
		(umask 066;openssl genrsa -out app.key 1024)  为app生成的私钥
		(umask 066;openssl genrsa -out app1.key 1024) 为app1生成的私钥
	2.根据生成的私钥再生成证书申请文件
		后缀为csr的证书申请文件
		openssl req -new -key app.key -out aap.csr

		Country Name (2 letter code) [XX]:CN 国家必须一致
		State or Province Name (full name) []:beijing 城市必须一致
		Locality Name (eg, city) [Default City]:beijing
		Organization Name (eg, company) [Default Company Ltd]:redhat.com CA机构
		Organizational Unit Name (eg, section) []:devops
		Common Name (eg, your name or your server's hostname) []:www.centos66.com  必填项，为哪个网站申请的证书域名，或者泛域名
		Email Address []:
	3. 将请求证书文件传输给CA(拷贝到CA服务器下/etc/pki/CA/目录)
		scp aap.csr 192.168.34.103:/etc/pki/CA/
	4.在CA(centos7)服务器上，检查并签署证书，将证书颁发给申请者(centos6)
		openssl ca -in aap.csr -out certs/app.crt -days 1000
	5.CA服务器签署证书后，可以查看具体的已签完的完整信息(即申请时填的信息和证书有效期)
		scp app.crt 192.168.34.101:/data
		可用openssl x509 -in app.crt -noout -text|issuer|subject|serial|dates
			openssl ca -status SERIAL 查看指定编号的证书状态
		后期在具体的服务的配置文件，将证书加进去就可以了

	(centos6上)申请服务器上：私钥：app.key 申请证书：app.csr 签署证书：app.crt

	CA服务器上的/etc/pki/CA的tree结构
	[root@centos7 CA]#tree
	.
	├── aap.csr         传过来的申请证书文件
	├── cacert.pem 		CA自签名证书
	├── certs 			被发布的证书存放目录
	│   └── app.crt 	已签署的证书名
	├── crl 			吊销证书存放目录
	├── crlnumber 		下一个被吊销的证书编号
	├── crlnumber.old 	
	├── crl.pem 		新的吊销证书列表
	├── index.txt 		记录颁发V/R吊销证书的编号和证书填写的主题信息
	├── index.txt.attr 	unique_subject = yes，多个证书请求填写信息必须不同
	├── index.txt.old 	颁发下一个证书前的数据库备份
	├── newcerts 		下一个颁发证书的存放目录
	│   └── 0F.pem 		和app.crt内容一样
	├── private 
	│   └── cakey.pem 	CA的私钥
	├── serial 			下一个证书的编号0F 10 11 12..
	└── serial.old 		上一个证书的编号的备份
## 吊销证书步骤：
	1.在服务端吊销指定的证书
		openssl ca -revoke certs/app.crt
	2.更新证书吊销列表，在互联网上公布
		a.先创建吊销证书列表文件编号,再创建证书吊销列表
			echo 01 > /etc/pki/CA/crlnumber
		b.更新证书吊销列表
			openssl ca -gencrl -out /etc/pki/CA/crl.pem
	3.可以用下面命令以文本方式查看吊销列表信息 
		openssl crl -in /etc/pki/CA/crl.pem -noout -text
## 用CA的证书来验证用户的证书
	openssl verify -CAfile cacert.pem certs/app.crt
	
	[root@centos7 CA]#openssl verify -CAfile cacert.pem certs/app.crt 
	certs/app.crt: OK














	






























































































































